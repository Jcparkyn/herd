use std::{str::FromStr,rc::Rc};
use crate::ast::{Expr, Opcode, Statement, Block, AssignmentTarget, VarRef, LambdaExpr};
use crate::parse_helpers::parse_string_literal;

grammar;

pub Program: Vec<Statement> = {
    Statement+
}

Statement: Statement = {
    StatementWithSemicolon,
    <ExprWithBlock> => Statement::Expression(<>),
}

StatementWithSemicolon: Statement = {
    <ExprWithoutBlock> ";" => Statement::Expression(<>),
    <name:Identifier> "=" <e:Expr> ";" => Statement::Declaration(VarRef::new(name), e),
    "set" <target:AssignmentTarget> "=" <e:Expr> ";" => Statement::Assignment(target, e),
    "return" <e:Expr> ";" => Statement::Return(e),
}

Expr = {
    ExprWithoutBlock,
    ExprWithBlock,
}

ExprWithoutBlock = {
    LogicExpr,
    <callee:Term> <args:Term+> => Box::new(Expr::Call { callee, args }),
    <lhs:Expr> "|" <callee:Term> <mut args:Term*> =>{
        args.insert(0, lhs);
        Box::new(Expr::Call { callee, args })
    },
}

// Expressions that don't need a trailing semicolon
ExprWithBlock: Box<Expr> = {
    IfExpression,
    "for" <var:Identifier> "in" <iter:Expr> "do" <body:BlockExpr> => Box::new(Expr::ForIn { var: VarRef::new(var), iter, body }),
    <BlockExpr> => Box::new(Expr::Block(<>)),
}

LogicExpr = Tier<LogicOp, ComparisonExpr>;

ComparisonExpr = Tier<ComparisonOp, AddSubExpr>;

AddSubExpr: Box<Expr> = {
    <lhs:AddSubExpr> <op:AddSubOp> <rhs:Factor> => Box::new(Expr::Op { op, lhs, rhs }),
    Factor,
}

Factor = Tier<FactorOp, Term>;

Term: Box<Expr> = {
    NumLiteral => Box::new(Expr::Number(<>)),
    BoolLiteral => Box::new(Expr::Bool(<>)),
    "nil" => Box::new(Expr::Nil),
    r"'[^']*'" => Box::new(Expr::String(parse_string_literal(<>))),
    Identifier => Box::new(Expr::Variable(VarRef::new(<>))),
    "(" <Expr> ")",
    LambdaExpr,
    DictLiteral,
    ArrayLiteral,
    <lhs:Term> <index:ValueIndex> => Box::new(Expr::GetIndex(lhs, index)),
};

ValueIndex: Box<Expr> = {
    "." <field:Identifier> => Box::new(Expr::String(field)),
    ".[" <index:Expr> "]" => index,
} 

AssignmentTarget: AssignmentTarget = {
    <var:Identifier> <path:ValueIndex*> => AssignmentTarget { var: VarRef::new(var), path },
}   

IfExpression: Box<Expr> = {
    "if " <cond:Expr> "then" <b1:BlockExpr> <b2:("else" <BlockExpr>)?> => Box::new(
        Expr::If { condition: cond, then_branch: b1, else_branch: b2 }
    )
}

BlockExpr: Block = {
    "{" <b:BlockBody> "}" => b
}

BlockBody: Block = {
    => Block { statements: vec![], expression: None },
    // separate patterns to remove ambiguity.
    // If there's no trailing semicolon it should always be an Expr.
    <s:Statement*> <e:Expr> => Block { statements: s, expression: Some(e) },
    <mut s1:Statement*> <s2:StatementWithSemicolon> => Block {
        statements: { s1.push(s2); s1 },
        expression: None,
    },
}

NumLiteral: f64 = {
    r"-?[0-9]+" => f64::from_str(<>).unwrap()
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

LambdaExpr: Box<Expr> = {
    "{" <params:Comma<Identifier>> "->" <body:BlockBody> "}" => Box::new(Expr::Lambda(
        LambdaExpr::new(params, Rc::new(body))
    ))
}

DictEntry: (String, Box<Expr>) = {
    <key:Identifier> ":" <val:Expr> => (key, val),
}

DictLiteral: Box<Expr> = {
    "[" <entries:CommaPlus<DictEntry>> "]" => Box::new(Expr::Dict(entries)),
    "[:]" => Box::new(Expr::Dict(vec![])),
}

ArrayLiteral: Box<Expr> = {
    "[" <elements:Comma<Expr>> "]" => Box::new(Expr::Array(elements)),
}

Identifier: String = {
    <r"[a-zA-Z]\w*"> => <>.to_string(),
}

LogicOp: Opcode = {
    "and" => Opcode::And,
    "or" => Opcode::Or,
}

ComparisonOp: Opcode = {
    ">" => Opcode::Gt,
    "<" => Opcode::Lt,
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
}

AddSubOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Tier<Op,NextTier>: Box<Expr> = {
    <lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Box::new(Expr::Op { op, lhs, rhs }),
    NextTier
};

CommaPlus<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v
    }
};

Comma<T>: Vec<T> = {
    CommaPlus<T>,
    => vec![],
}