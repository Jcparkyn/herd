use std::{str::FromStr,rc::Rc};
use crate::ast;
use crate::pos::{Span, Spanned};
use crate::ast::{Expr, Opcode, Statement, Block, AssignmentTarget, VarRef, LambdaExpr, MatchPattern, MatchExpr};
use crate::parse_helpers::{
    parse_string_literal,
    process_list_match,
    process_declaration,
    make_implicit_lambda,
};

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

pub Program: Vec<ast::SpannedStatement> = {
    SpStatement+
}

Statement: Statement = {
    StatementWithSemicolon,
    Sp<ExprWithBlock> => Statement::Expression(<>),
}

StatementWithSemicolon: Statement = {
    <e:Sp<ExprWithoutBlock>> ";" => Statement::Expression(e),
    <decl_type:DeclarationType> <name:Sp<Identifier>> "=" <e:SpExpr> ";" =>
        process_declaration(name, decl_type, e),
    "set" <target:Sp<AssignmentTarget>> "=" <e:SpExpr> ";" =>
        Statement::PatternAssignment(target.map(MatchPattern::Assignment), e),
    "!" <pattern:Sp<MatchPattern>> "=" <e:SpExpr> ";" =>
        Statement::PatternAssignment(pattern, e),
    "return" <e:SpExpr> ";" => Statement::Return(e),
    <span:Sp<"return">> ";" => Statement::Return(Spanned::new(span.span, Expr::Nil)),
}

Expr = {
    ExprWithoutBlock,
    ExprWithBlock,
}

ExprWithoutBlock = {
    LogicExpr,
    <lhs:SpExpr> "|" <callee:Sp<Term>> <mut args:Sp<Term>*> => {
        args.insert(0, lhs);
        Expr::Call { callee: Box::new(callee), args }
    },
}

// Expressions that don't need a trailing semicolon
ExprWithBlock: Expr = {
    IfExpr,
    MatchExpr,
    "for" <var:Sp<MatchPattern>> "in" <iter:Box<SpExpr>> "do" <body:BlockExpr> =>
        Expr::ForIn { var, iter, body },
    "while" <condition:Box<SpExpr>> "do" <body:Box<Sp<Term>>> =>
        Expr::While { condition, body },
    // No blocks here at the moment, because they conflict with using block expression as terms
    // <BlockExpr> => Box::new(Expr::Block(<>)),
}

LogicExpr = Tier<LogicOp, ComparisonExpr>;

ComparisonExpr = Tier<ComparisonOp, AddSubCallExpr>;

AddSubCallExpr: Expr = {
    <callee:Box<Sp<Term>>> <args:Sp<Term>+> => Expr::Call { callee, args },
    AddSubExpr,
}

AddSubExpr = Tier<AddSubOp, Factor>;

Factor = Tier<FactorOp, Term>;

Term: Expr = {
    NumLiteral => Expr::Number(<>),
    BoolLiteral => Expr::Bool(<>),
    "nil" => Expr::Nil,
    StringLiteral => Expr::from_string(<>),
    Identifier => Expr::Variable(VarRef::new(<>)),
    LambdaExpr,
    DictLiteral,
    ListLiteral,
    <BlockExpr> => Expr::Block(<>),
    <lhs:Sp<Term>> <index:Sp<ValueIndex>> => Expr::GetIndex(Box::new(lhs), Box::new(index)),
};

ValueIndex: Expr = {
    "." <field:Identifier> => Expr::from_string(field),
    ".[" <index:Expr> "]" => index,
} 

AssignmentTarget: AssignmentTarget = {
    <var:Identifier> <path:Sp<ValueIndex>*> => AssignmentTarget { var: VarRef::new(var), path },
}

MatchPattern: MatchPattern = {
    <decl_type:DeclarationType> <var:Identifier> => {
        if var == "_" {
            MatchPattern::Discard
        } else {
            MatchPattern::Declaration(VarRef::new(var), decl_type)
        }
    },
    "set" <target:AssignmentTarget> => MatchPattern::Assignment(target),
    "[" <parts:Comma<MatchListPart>> "]" =>? Ok(process_list_match(parts)?),
    NumLiteral => MatchPattern::Constant(ast::MatchConstant::Number(<>)),
    BoolLiteral => MatchPattern::Constant(ast::MatchConstant::Bool(<>)),
    StringLiteral => MatchPattern::Constant(ast::MatchConstant::String(<>)),
    "nil" => MatchPattern::Constant(ast::MatchConstant::Nil),
}

#[inline]
DeclarationType: ast::DeclarationType = {
    "var" => ast::DeclarationType::Mutable,
    () => ast::DeclarationType::Const,
}

MatchListPart: (MatchPattern, bool) = {
    <spread:".."?> <pattern:MatchPattern> => (pattern, spread != None),
    ".." => (MatchPattern::Discard, true),
}

IfExpr: Expr =
    "if " <cond:SpExpr> "then" <b1:Sp<Term>> <b2:("else" <Box<Sp<Term>>>)?> =>
        Expr::If {
            condition: Box::new(cond),
            then_branch: Box::new(b1),
            else_branch: b2,
        };

MatchExpr: Expr =
    "match" <condition:SpExpr> "with" "{" <branches:CommaNonEmpty<MatchExprBranch>> "}" =>
        Expr::Match(Box::new(MatchExpr { condition, branches }));

MatchExprBranch: (Spanned<MatchPattern>, ast::SpannedExpr) =
    <p:Sp<MatchPattern>> "=>" <e:SpExpr> => (p, e);

BlockExpr: Block = {
    "(" <b:BlockBody> ")" => b
}

BlockBody: Block = {
    => Block { statements: vec![], expression: None },
    // separate patterns to remove ambiguity.
    // If there's no trailing semicolon it should always be an Expr.
    <s:SpStatement*> <e:SpExpr> => Block { statements: s, expression: Some(Box::new(e)) },
    <mut s1:SpStatement*> <s2:Sp<StatementWithSemicolon>> => Block {
        statements: { s1.push(s2); s1 },
        expression: None,
    },
}

NumLiteral: f64 = {
    r"-?[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap()
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: String = {
    r"'[^']*'" => parse_string_literal(<>),
}

LambdaExpr: Expr = {
    "{" <params:Sp<MatchPattern>*> "->" <body:Sp<BlockBody>> "}" => Expr::Lambda(
        LambdaExpr::new(params, Rc::new(body.map(Expr::Block)))
    ),
    "{" "{" <body:Sp<BlockBody>> "}" "}" => make_implicit_lambda(body),
}

DictEntry: (ast::SpannedExpr, ast::SpannedExpr) = {
    <key:SpIdentifier> ":" <val:SpExpr> => (key, val),
    "[" <key:SpExpr> "]" ":" <val:SpExpr> => (key, val),
}

DictLiteral: Expr = {
    "[" <entries:CommaNonEmpty<DictEntry>> "]" => Expr::Dict(entries),
    "[:]" => Expr::Dict(vec![]),
}

ListLiteral: Expr = {
    "[" <elements:Comma<SpExpr>> "]" => Expr::List(elements),
}

Identifier: String = {
    <r"[a-zA-Z]\w*"> => <>.to_string(),
    "_" => <>.to_string(),
}

SpIdentifier: ast::SpannedExpr = Sp<Identifier> => <>.map(Expr::from_string);

LogicOp: Opcode = {
    "and" => Opcode::And,
    "or" => Opcode::Or,
}

ComparisonOp: Opcode = {
    ">" => Opcode::Gt,
    ">=" => Opcode::Gte,
    "<" => Opcode::Lt,
    "<=" => Opcode::Lte,
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
}

AddSubOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Tier<Op,NextTier>: Expr = {
    <lhs:Sp<Tier<Op,NextTier>>> <op:Op> <rhs:Sp<NextTier>> =>
        Expr::Op { op, lhs: Box::new(lhs), rhs: Box::new(rhs) },
    NextTier
};

Sp<Rule>: Spanned<Rule> =
    <l: @L> <rule: Rule> <r: @R> => Spanned::new(
        Span::new(l, r),
        rule,
    );

SpExpr = Sp<Expr>;

SpStatement: ast::SpannedStatement = Sp<Statement>;

Box<T>: Box<T> = T => Box::new(<>);

#[inline]
CommaNonEmpty<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:(<T> ","?)> => {
        v.push(e);
        v
    }
};

#[inline]
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}
