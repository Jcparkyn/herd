use std::{str::FromStr,rc::Rc};
use crate::ast;
use crate::pos;
use crate::ast::{Expr, Opcode, Statement, Block, AssignmentTarget, VarRef, LambdaExpr, MatchPattern, MatchExpr};
use crate::parse_helpers::{
    parse_string_literal,
    process_array_match,
    process_declaration,
    make_implicit_lambda,
};

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

pub Program: Vec<ast::SpannedStatement> = {
    SpStatement+
}

Statement: Statement = {
    StatementWithSemicolon,
    <ExprWithBlock> => Statement::Expression(Box::new(<>)),
}

StatementWithSemicolon: Statement = {
    <ExprWithoutBlock> ";" => Statement::Expression(Box::new(<>)),
    <name:Identifier> "=" <e:Expr> ";" => process_declaration(name, e),
    "set" <target:AssignmentTarget> "=" <e:Box<Expr>> ";" =>
        Statement::PatternAssignment(MatchPattern::Assignment(target), e),
    "!" <pattern:MatchPattern> "=" <e:Expr> ";" => Statement::PatternAssignment(pattern, Box::new(e)),
    "return" <e:Expr> ";" => Statement::Return(Box::new(e)),
    "return" ";" => Statement::Return(Box::new(Expr::Nil)),
}

Expr = {
    ExprWithoutBlock,
    ExprWithBlock,
}

ExprWithoutBlock = {
    LogicExpr,
    <lhs:Expr> "|" <callee:Term> <mut args:Term*> => {
        args.insert(0, lhs);
        Expr::Call { callee: Box::new(callee), args }
    },
}

// Expressions that don't need a trailing semicolon
ExprWithBlock: Expr = {
    IfExpression,
    MatchExpr,
    "for" <var:Identifier> "in" <iter:Box<Expr>> "do" <body:BlockExpr> =>
        Expr::ForIn { var: VarRef::new(var), iter, body },
    "while" <condition:Box<Expr>> "do" <body:Box<Term>> =>
        Expr::While { condition, body },
    // No blocks here at the moment, because they conflict with using block expression as terms
    // <BlockExpr> => Box::new(Expr::Block(<>)),
}

LogicExpr = Tier<LogicOp, ComparisonExpr>;

ComparisonExpr = Tier<ComparisonOp, AddSubCallExpr>;

AddSubCallExpr: Expr = {
    <callee:Box<Term>> <args:Term+> => Expr::Call { callee, args },
    AddSubExpr,
}

AddSubExpr: Expr = {
    <lhs:AddSubExpr> <op:AddSubOp> <rhs:Factor> =>
        Expr::Op { op, lhs: Box::new(lhs), rhs: Box::new(rhs) },
    Factor,
}

Factor = Tier<FactorOp, Term>;

Term: Expr = {
    NumLiteral => Expr::Number(<>),
    BoolLiteral => Expr::Bool(<>),
    "nil" => Expr::Nil,
    StringLiteral => Expr::from_string(<>),
    Identifier => Expr::Variable(VarRef::new(<>)),
    LambdaExpr,
    DictLiteral,
    ArrayLiteral,
    <BlockExpr> => Expr::Block(<>),
    <lhs:Term> <index:ValueIndex> => Expr::GetIndex(Box::new(lhs), Box::new(index)),
};

ValueIndex: Expr = {
    "." <field:Identifier> => Expr::from_string(field),
    ".[" <index:Expr> "]" => index,
} 

AssignmentTarget: AssignmentTarget = {
    <var:Identifier> <path:ValueIndex*> => AssignmentTarget { var: VarRef::new(var), path },
}

MatchPattern: MatchPattern = {
    <var:Identifier> => {
        if var == "_" {
            MatchPattern::Discard
        } else {
            MatchPattern::Declaration(VarRef::new(var))
        }
    },
    "set" <target:AssignmentTarget> => MatchPattern::Assignment(target),
    "[" <parts:Comma<MatchArrayPart>> "]" =>? Ok(process_array_match(parts)?),
    NumLiteral => MatchPattern::Constant(ast::MatchConstant::Number(<>)),
    BoolLiteral => MatchPattern::Constant(ast::MatchConstant::Bool(<>)),
    StringLiteral => MatchPattern::Constant(ast::MatchConstant::String(<>)),
    "nil" => MatchPattern::Constant(ast::MatchConstant::Nil),
}

MatchArrayPart: (MatchPattern, bool) = {
    <spread:".."?> <pattern:MatchPattern> => (pattern, spread != None),
    ".." => (MatchPattern::Discard, true),
}

IfExpression: Expr =
    "if " <cond:Expr> "then" <b1:Term> <b2:("else" <Box<Term>>)?> =>
        Expr::If {
            condition: Box::new(cond),
            then_branch: Box::new(b1),
            else_branch: b2,
        };

MatchExpr: Expr =
    "match" <condition:Expr> "with" "{" <branches:CommaNonEmpty<MatchExprBranch>> "}" =>
        Expr::Match(Box::new(MatchExpr { condition, branches }));

MatchExprBranch: (MatchPattern, Expr) =
    <p:MatchPattern> "=>" <e:Expr> => (p, e);

BlockExpr: Block = {
    "(" <b:BlockBody> ")" => b
}

BlockBody: Block = {
    => Block { statements: vec![], expression: None },
    // separate patterns to remove ambiguity.
    // If there's no trailing semicolon it should always be an Expr.
    <s:SpStatement*> <e:Expr> => Block { statements: s, expression: Some(Box::new(e)) },
    <mut s1:SpStatement*> <s2:Sp<StatementWithSemicolon>> => Block {
        statements: { s1.push(s2); s1 },
        expression: None,
    },
}

NumLiteral: f64 = {
    r"-?[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap()
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: String = {
    r"'[^']*'" => parse_string_literal(<>),
}

LambdaExpr: Expr = {
    "{" <params:MatchPattern*> "->" <body:BlockBody> "}" => Expr::Lambda(
        LambdaExpr::new(params, Rc::new(Expr::Block(body)))
    ),
    "{" "{" <body:BlockBody> "}" "}" => make_implicit_lambda(body),
}

DictEntry: (Expr, Expr) = {
    <key:Identifier> ":" <val:Expr> => (Expr::from_string(key), val),
    "[" <key:Expr> "]" ":" <val:Expr> => (key, val),
}

DictLiteral: Expr = {
    "[" <entries:CommaNonEmpty<DictEntry>> "]" => Expr::Dict(entries),
    "[:]" => Expr::Dict(vec![]),
}

ArrayLiteral: Expr = {
    "[" <elements:Comma<Expr>> "]" => Expr::Array(elements),
}

Identifier: String = {
    <r"[a-zA-Z]\w*"> => <>.to_string(),
    "_" => <>.to_string(),
}

LogicOp: Opcode = {
    "and" => Opcode::And,
    "or" => Opcode::Or,
}

ComparisonOp: Opcode = {
    ">" => Opcode::Gt,
    ">=" => Opcode::Gte,
    "<" => Opcode::Lt,
    "<=" => Opcode::Lte,
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
}

AddSubOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Tier<Op,NextTier>: Expr = {
    <lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> =>
        Expr::Op { op, lhs: Box::new(lhs), rhs: Box::new(rhs) },
    NextTier
};

Sp<Rule>: pos::Spanned<Rule> =
    <l: @L> <rule: Rule> <r: @R> => pos::Spanned::new(
        pos::Span::new(l, r),
        rule,
    );

SpStatement: ast::SpannedStatement = Sp<Statement>;

Box<T>: Box<T> = T => Box::new(<>);

#[inline]
CommaNonEmpty<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:(<T> ","?)> => {
        v.push(e);
        v
    }
};

#[inline]
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}
