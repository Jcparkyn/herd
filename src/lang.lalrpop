use std::{str::FromStr,rc::Rc};
use crate::ast;
use crate::ast::{Expr, Opcode, Statement, Block, AssignmentTarget, VarRef, LambdaExpr, MatchPattern, MatchExpr};
use crate::parse_helpers::{parse_string_literal, process_array_match, process_declaration};

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}

pub Program: Vec<Statement> = {
    Statement+
}

Statement: Statement = {
    StatementWithSemicolon,
    <ExprWithBlock> => Statement::Expression(<>),
}

StatementWithSemicolon: Statement = {
    <ExprWithoutBlock> ";" => Statement::Expression(<>),
    <name:Identifier> "=" <e:Expr> ";" => process_declaration(name, e),
    "set" <target:AssignmentTarget> "=" <e:Expr> ";" => Statement::PatternAssignment(MatchPattern::Assignment(target), e),
    "!" <pattern:MatchPattern> "=" <e:Expr> ";" => Statement::PatternAssignment(pattern, e),
    "return" <e:Expr> ";" => Statement::Return(e),
}

Expr = {
    ExprWithoutBlock,
    ExprWithBlock,
}

ExprWithoutBlock = {
    LogicExpr,
    <lhs:Expr> "|" <callee:Term> <mut args:Term*> => {
        args.insert(0, lhs);
        Box::new(Expr::Call { callee, args })
    },
}

// Expressions that don't need a trailing semicolon
ExprWithBlock: Box<Expr> = {
    IfExpression,
    MatchExpr,
    "for" <var:Identifier> "in" <iter:Expr> "do" <body:BlockExpr> => Box::new(Expr::ForIn { var: VarRef::new(var), iter, body }),
    // No blocks here at the moment, because they conflict with using block expression as terms
    // <BlockExpr> => Box::new(Expr::Block(<>)),
}

LogicExpr = Tier<LogicOp, ComparisonExpr>;

ComparisonExpr = Tier<ComparisonOp, AddSubCallExpr>;

AddSubCallExpr: Box<Expr> = {
    <callee:Term> <args:Term+> => Box::new(Expr::Call { callee, args }),
    AddSubExpr,
}

AddSubExpr: Box<Expr> = {
    <lhs:AddSubExpr> <op:AddSubOp> <rhs:Factor> => Box::new(Expr::Op { op, lhs, rhs }),
    Factor,
}

Factor = Tier<FactorOp, Term>;

Term: Box<Expr> = {
    NumLiteral => Box::new(Expr::Number(<>)),
    BoolLiteral => Box::new(Expr::Bool(<>)),
    "nil" => Box::new(Expr::Nil),
    StringLiteral => Box::new(Expr::from_string(<>)),
    Identifier => Box::new(Expr::Variable(VarRef::new(<>))),
    LambdaExpr,
    DictLiteral,
    ArrayLiteral,
    <BlockExpr> => Box::new(Expr::Block(<>)),
    <lhs:Term> <index:ValueIndex> => Box::new(Expr::GetIndex(lhs, index)),
};

ValueIndex: Box<Expr> = {
    "." <field:Identifier> => Box::new(Expr::from_string(field)),
    ".[" <index:Expr> "]" => index,
} 

AssignmentTarget: AssignmentTarget = {
    <var:Identifier> <path:ValueIndex*> => AssignmentTarget { var: VarRef::new(var), path },
}

MatchPattern: MatchPattern = {
    <var:Identifier> => {
        if var == "_" {
            MatchPattern::Discard
        } else {
            MatchPattern::Declaration(VarRef::new(var))
        }
    },
    "set" <target:AssignmentTarget> => MatchPattern::Assignment(target),
    "[" <parts:Comma<MatchArrayPart>> "]" =>? Ok(process_array_match(parts)?),
    NumLiteral => MatchPattern::Constant(ast::MatchConstant::Number(<>)),
    BoolLiteral => MatchPattern::Constant(ast::MatchConstant::Bool(<>)),
    StringLiteral => MatchPattern::Constant(ast::MatchConstant::String(<>)),
    "nil" => MatchPattern::Constant(ast::MatchConstant::Nil),
}

MatchArrayPart: (MatchPattern, bool) = {
    <spread:".."?> <pattern:MatchPattern> => (pattern, spread != None),
    ".." => (MatchPattern::Discard, true),
}

IfExpression: Box<Expr> = {
    "if " <cond:Expr> "then" <b1:Term> <b2:("else" <Term>)?> => Box::new(
        Expr::If { condition: cond, then_branch: b1, else_branch: b2 }
    )
}

MatchExpr: Box<Expr> = {
    "match" <condition:Expr> "with" "{" <branches:CommaNonEmpty<MatchExprBranch>> "}" => Box::new(
        Expr::Match(MatchExpr { condition, branches })
    )
}

MatchExprBranch: (MatchPattern, Box<Expr>) = {
    <p:MatchPattern> "=>" <e:Expr> => (p, e),
}

BlockExpr: Block = {
    "(" <b:BlockBody> ")" => b
}

BlockBody: Block = {
    => Block { statements: vec![], expression: None },
    // separate patterns to remove ambiguity.
    // If there's no trailing semicolon it should always be an Expr.
    <s:Statement*> <e:Expr> => Block { statements: s, expression: Some(e) },
    <mut s1:Statement*> <s2:StatementWithSemicolon> => Block {
        statements: { s1.push(s2); s1 },
        expression: None,
    },
}

NumLiteral: f64 = {
    r"-?[0-9]+" => f64::from_str(<>).unwrap()
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: String = {
    r"'[^']*'" => parse_string_literal(<>),
}

LambdaExpr: Box<Expr> = {
    "{" <params:Identifier*> "->" <body:BlockBody> "}" => Box::new(Expr::Lambda(
        LambdaExpr::new(params, Rc::new(Expr::Block(body)))
    )),
    "{" "{" <body:BlockBody> "}" "}" => Box::new(Expr::Lambda(
        LambdaExpr::new(vec!["_".to_string()], Rc::new(Expr::Block(body)))
    )),
}

DictEntry: (Box<Expr>, Box<Expr>) = {
    <key:Identifier> ":" <val:Expr> => (Box::new(Expr::from_string(key)), val),
    "[" <key:Expr> "]" ":" <val:Expr> => (key, val),
}

DictLiteral: Box<Expr> = {
    "[" <entries:CommaNonEmpty<DictEntry>> "]" => Box::new(Expr::Dict(entries)),
    "[:]" => Box::new(Expr::Dict(vec![])),
}

ArrayLiteral: Box<Expr> = {
    "[" <elements:Comma<Expr>> "]" => Box::new(Expr::Array(elements)),
}

Identifier: String = {
    <r"[a-zA-Z]\w*"> => <>.to_string(),
    "_" => <>.to_string(),
}

LogicOp: Opcode = {
    "and" => Opcode::And,
    "or" => Opcode::Or,
}

ComparisonOp: Opcode = {
    ">" => Opcode::Gt,
    "<" => Opcode::Lt,
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
}

AddSubOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Tier<Op,NextTier>: Box<Expr> = {
    <lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Box::new(Expr::Op { op, lhs, rhs }),
    NextTier
};

#[inline]
CommaNonEmpty<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:(<T> ","?)> => {
        v.push(e);
        v
    }
};

#[inline]
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}