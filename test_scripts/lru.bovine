
tmpLRU = [
  size: 20,
  oldest: 'a',
  newest: 'c',
  items: [
    a: [69, nil, 'b'],
    b: [7, 'a', 'c'],
    c: [420, 'b', nil],
  ],
];

newLRU = { size -> [
  size: size,
  items: [:],
]};

removeOldest = { lru ->
  if len lru.items == 0 then (
    return lru;
  )
  oldest_tuple = lru.items.[lru.oldest];
  // set lru.items |= removeKey lru.oldest;
  set lru.items = lru.items | removeKey lru.oldest;
  new_oldest = oldest_tuple.[2];
  set lru.oldest = new_oldest;
  set lru.[new_oldest].[1] = nil;
  lru
};

get = { lru key ->
  if len lru.items == 0 then (
    return [lru, nil];
  )
  val = lru.items.[key];
  if val == nil then ( return [lru, nil]; )
  prev = val.[1];
  next = val.[2];
  if prev != nil then (
    set lru.items.[prev].[2] = next;
  )
  if next != nil then (
    set lru.items.[next].[1] = prev;
  )

  if lru.oldest == key then (
    set lru.oldest = next;
  )

  set lru.items.[lru.newest].[2] = key;
  set lru.items.[key] = [val.[0], lru.newest, nil];
  set lru.newest = key;
  [lru, val.[0]]
};

put = { lru key value ->
  // empty LRU
  if len lru.items == 0 then (
    set lru.oldest = key;
    set lru.newest = key;
    set lru.items.[key] = [value, nil, nil];
    return lru;
  )

  ![set lru, val] = get lru key;

  // Key exists
  if val != nil then (
    set lru.items.[key].[0] = value;
    return lru;
  )
  // Key doesn't exist
  if len lru.items == lru.size then (
    set lru = lru | removeOldest;
  )
  set lru.items.[key] = [value, lru.newest, nil];
  set lru.items.[lru.newest].[2] = key;
  set lru.newest = key;
  lru
};

main = { _ ->
  lru = newLRU 10
    | put 'a' 69
    | put 'b' 420
    | put 'c' 7;
  print (get lru 'a');
};

main 0;
