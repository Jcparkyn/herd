
formatLetter = \c isUsed isLast\ (
  if isLast then (
    '\e[93;4m' ++ c ++ '\e[0m'
  ) else if isUsed then (
    '\e[90;1m' ++ c ++ '\e[0m'
  ) else (
    '\e[92;4m' ++ c ++ '\e[0m'
  )
);

render = \state\ (
  !{ edgeLetters, entered } = state;

  println '\x1B[2J\x1B[H'; // clear screen

  var renderLetters = edgeLetters;
  enteredAll = List.flatten entered;
  for i in range 0 (len edgeLetters) do (
    isUsed = enteredAll | List.contains i;
    isLast = (len entered) > 0 and i == entered.[-1].[-1];
    set renderLetters.[i] |= formatLetter isUsed isLast;
  )

  if state.errorMessage then (
    println ('\n\e[31mError: ' ++ state.errorMessage ++ '\e[0m\n');
  ) else (
    println '\n\n\n';
  )
  printf [' ', renderLetters.[0], ' ', renderLetters.[1], ' ', renderLetters.[2], ' '];
  printf [renderLetters.[11], ' ', ' ', ' ', ' ', ' ', renderLetters.[3]];
  printf [renderLetters.[10], ' ', ' ', ' ', ' ', ' ', renderLetters.[4]];
  printf [renderLetters.[9], ' ', ' ', ' ', ' ', ' ', renderLetters.[5]];
  printf [' ', renderLetters.[8], ' ', renderLetters.[7], ' ', renderLetters.[6], ' '];

  getWord = \indices\ (
    var word = '';
    for i in indices do (
      set word = word ++ edgeLetters.[i];
    )
    word
  );

  enteredWords = entered
    | map getWord;

  println '';
  println (enteredWords | String.join ', ');
);

indexToSide = \i\ (
  if i < 3 then 'top'
  else if i < 6 then 'right'
  else if i < 9 then 'bottom'
  else 'left'
);

validateIndicesOnDifferentSides = \indices\ (
  sides = indices
    | map indexToSide;

  var previousSide = '';
  for side in sides do (
    if side == previousSide then (
      return false;
    )
    set previousSide = side;
  )
  true
);

handleSubmit = \var state wordSet newWord\ (
  newWordIndices = newWord
    | String.toUpper
    | String.toChars
    | map \(List.indexOf state.edgeLetters _);

  if (newWordIndices | len) < 2 then (
    set state.errorMessage = 'Word must be at least 2 letters';
    return state;
  )

  if newWordIndices | List.contains (-1) then (
    set state.errorMessage = 'Invalid letters used';
    return state;
  )

  if (len state.entered) > 0 and newWordIndices.[0] != state.entered.[-1].[-1] then (
    set state.errorMessage = 'Word must start with the last letter of the previous word';
    return state;
  )

  if not (validateIndicesOnDifferentSides newWordIndices) then (
    set state.errorMessage = 'Can\'t use letters from the same side twice in a row';
    return state;
  )

  if not wordSet.[newWord] then (
    set state.errorMessage = 'Word not found in dictionary';
    return state;
  )

  set state.entered |= push newWordIndices;
  state
);

handleUndo = \var state\ (
  if (len state.entered) == 0 then (
    return state;
  )
  set state.entered |= pop;
  state
);

// A rather silly function to generate a valid board from two random words, so the game always has a two-word solution.
generateBoard = \wordList\ (

  // Check if a word is eligible to be used in the solution.
  wordEligible = \word\ (
    l = len word;
    if l < 5 or l > 8 then (
      return false;
    )
    hasDuplicates = word
      | String.toChars
      | List.window 2
      | List.any (\[a, b]\ a == b);
    not hasDuplicates
  );

  arrangeBoard = \w1 w2\ (
    chars1 = String.toChars w1;
    chars2 = String.toChars w2;
    chars = chars1 ++ (chars2 | List.slice 1 (len chars2));
    var result = List.repeat () 12;
    var currentSide = ();
    for char in chars do (
      existingIndex = result | List.indexOf char;
      if existingIndex != (-1) then (
        nextSide = indexToSide existingIndex;
        if nextSide == currentSide then (
          // Conflict - can't place letter on same side as previous letter
          printf ['Conflict placing ', char, ' at index ', existingIndex, ' on side ', nextSide];
          return ();
        )
        set currentSide = nextSide;
      ) else (
        var availableIndices = range 0 12
          // Must be on different side to previous letter
          | List.filter (\i\ indexToSide i != currentSide)
          // Must not have been used yet
          | List.filter (\i\ result.[i] == ());
        if availableIndices == [] then (
          printf ['Aborting arrangement at ', result];
          return ();
        )
        nextIndex = Random.choice availableIndices;
        set currentSide = indexToSide nextIndex;
        set result.[nextIndex] = char;
      )
    )
    result
  );

  eligibleWords = wordList | List.filter wordEligible;

  groupedByFirstChar = eligibleWords
    | List.groupBy (\word\ (String.toChars word).[0]);

  attempt = \\ (
    word1 = Random.choice eligibleWords;
    l1 = len word1;
    overlapChar = (String.toChars word1).[-1];
    desiredLength = 12 - l1 + 3;
    word2 = groupedByFirstChar.[overlapChar]
      | List.filter (\word\ len word == desiredLength)
      | Random.choice;
    if word2 == () then (
      return ();
    )
    
    printf ['Trying ', word1, ' and ', word2];
    l2 = len word2;

    uniqueChars = (String.toChars (word1 ++ word2))
      | List.distinct;

    if len uniqueChars != 12 then (
      println ' - wrong number of unique letters';
      return ();
    )

    printf ['Selected ', word1, ' and ', word2, '\n'];
    edgeLetters = arrangeBoard word1 word2;
    if edgeLetters == () then (
      println ' - couldn\'t arrange letters';
      return ();
    )
    return { edgeLetters, solution: [word1, word2] };
  );

  MAX_ATTEMPTS = 1000;
  for idx in range 1 MAX_ATTEMPTS do (
    switch attempt () on {
      () => (),
      result => (
        printf ['Board generated successfully (', idx, ' attempts): ', result];
        return result;
      ),
    }
  )
  printf ['Failed to generate board after ', MAX_ATTEMPTS, ' attempts'];
);

main = \\ (
  wordList = File.readLines 'test_scripts/dictionary.txt';

  !{ edgeLetters, solution } = generateBoard wordList;

  wordSet = wordList
    | map \([_, true])
    | Dict.fromEntries;

  var state = {
    edgeLetters,
    entered: [],
    errorMessage: (),
    solution,
  };

  render state;

  for i in range 0 100 do (
    line = IO.readline ();
    if line == 'exit' then (
      return;
    )
    set state.errorMessage = ();
    switch line on {
      '/undo' => (
        set state = handleUndo state;
      ),
      '/cheat' => (
        set state.errorMessage = solution | String.join ', ';
      ),
      '/reset' => (
        set state.entered = [];
      ),
      _ => (
        newWord = line | String.toUpper;
        set state = handleSubmit state wordSet newWord;
      ),
    }
    render state;
  )
);

main ();